{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting started","text":"<p>This library is here to help abstract all the operations that involve the operating system the PHP code run on.</p> <p>This kind of abstraction is useful to move away from implementation details and towards user intentions. By abstracting implementations details it becomes easier to port an application into a new environment and accomodate the differences at the implementation level without any change in the user intentions.</p> <p>The other advantage to use higher level abstractions is to enable end user to build more complex applications by freeing them from thinking of low level details.</p> <p>For concrete examples have a look at the use cases available in the sidebar.</p> <p>This library is a small overlay on top of a set of individual libraries that contain the concrete abstractions. So you can start using only a subset of abstractions in your code as a starting point.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>composer require innmind/operating-system\n</code></pre>"},{"location":"#basic-usage","title":"Basic usage","text":"<pre><code>use Innmind\\OperatingSystem\\Factory;\n\n$os = Factory::build();\n</code></pre> <p>There's nothing more to add to start using this abstraction. Head toward the use cases to understand all the things you can do with it.</p> <p>This library doesn't work on windows environments.</p>"},{"location":"advanced/extensions/","title":"Extensions","text":"<p>The advantage of having all operating system's operations done through a single abstraction is that you can easily add behaviour on top of that.</p>"},{"location":"advanced/extensions/#debugger","title":"Debugger","text":"<p>The <code>innmind/debug</code> library provides a decorator that will send all the operations of the operating system to your profiler (<code>innmind/profiler</code>).</p> <p>This debugger works for both http requests and cli applications.</p>"},{"location":"advanced/extensions/#silent-cartographer","title":"Silent Cartographer","text":"<p>The <code>innmind/silent-cartographer</code> is a CLI tool that will display all operating system's operations from all the PHP processes using this extension. This is useful when you want a glance at what's going on on your machine without the need to go through all the log files (if there's any).</p>"},{"location":"advanced/logging/","title":"Logging all operations","text":"<p>If you want to trace everything that is done on your operating system you can use the logger decorator that will automatically write to your log file (almost) all operations.</p> <pre><code>use Innmind\\OperatingSystem\\Config\\Logger;\nuse Psr\\Log\\LoggerInterface;\n\n$os = $os-&gt;map(\n    Logger::psr(/* any instance of LoggerInterface */),\n);\n</code></pre> <p>Now operations done with the new <code>$os</code> object will be written to your logs.</p>"},{"location":"upgrade/v5-to-v6/","title":"V5 to V6","text":""},{"location":"upgrade/v5-to-v6/#resilient-decorator","title":"Resilient decorator","text":"BeforeAfter <pre><code>use Innmind\\OperatingSystem\\OperatingSystem\\Resilient;\n\n$os = Resilient::of($os);\n</code></pre> <pre><code>use Innmind\\OperatingSystem\\Config\\Resilient;\n\n$os = $os-&gt;map(Resilient::new());\n</code></pre>"},{"location":"upgrade/v5-to-v6/#logger-decorator","title":"Logger decorator","text":"BeforeAfter <pre><code>use Innmind\\OperatingSystem\\OperatingSystem\\Logger;\nuse Psr\\Log\\LoggerInterface\n\n$os = Logger::psr($os, /* instance of LoggerInterface */);\n</code></pre> <pre><code>use Innmind\\OperatingSystem\\Config\\Logger;\n\n$os = $os-&gt;map(Logger::psr(/* instance of LoggerInterface */));\n</code></pre>"},{"location":"upgrade/v5-to-v6/#http-client-config","title":"HTTP client config","text":"BeforeAfter <pre><code>use Innmind\\OperatingSystem\\{\n    Factory,\n    Config,\n};\nuse Innmind\\TimeContinuum\\Earth\\ElapsedPeriod;\n\n$os = Factory::build(\n    Config::of()\n        -&gt;disableSSLVerification()\n        -&gt;limitHttpConcurrencyTo(10)\n        -&gt;withHttpHeartbeat(\n            ElapsedPeriod::of(1_000),\n            static fn() =&gt; 'heartbeat',\n        ),\n);\n</code></pre> <pre><code>use Innmind\\OperatingSystem\\{\n    Factory,\n    Config,\n};\nuse Innmind\\HttpTransport\\Curl;\nuse Innmind\\TimeContinuum\\Period;\n\n$config = Config::new();\n$os = Factory::build(\n    $config-&gt;useHttpTransport(\n        Curl::of($config-&gt;clock(), $config-&gt;io())\n            -&gt;disableSSLVerification()\n            -&gt;maxConcurrency(10)\n            -&gt;heartbeat(\n                Period::second(1),\n                static fn() =&gt; 'heartbeat',\n            ),\n    ),\n);\n</code></pre>"},{"location":"upgrade/v5-to-v6/#filesystem-config","title":"Filesystem config","text":"BeforeAfter <pre><code>use Innmind\\OperatingSystem\\{\n    Factory,\n    Config,\n};\nuse Innmind\\Filesystem\\CaseSensitivity;\n\n$os = Factory::build(\n    Config::of()-&gt;caseInsensitiveFilesystem(\n        CaseSensitivity::insensitive,\n    ),\n);\n</code></pre> <pre><code>use Innmind\\OperatingSystem\\{\n    Factory,\n    Config,\n};\nuse Innmind\\Filesystem\\{\n    Adapter\\Filesystem,\n    CaseSensitivity,\n};\n\n$os = Factory::build(\n    Config::new()-&gt;mountFilesystemVia(\n        static fn(Path $path, Config $config) =&gt; Filesystem::mount(\n            $path,\n            $config-&gt;io(),\n        )-&gt;withCaseSentitivity(\n            CaseSensitivity::insensitive,\n        ),\n    ),\n);\n</code></pre>"},{"location":"upgrade/v5-to-v6/#current-process-id","title":"Current process id","text":"BeforeAfter <pre><code>$os-&gt;process()-&gt;id();\n</code></pre> <pre><code>$os-&gt;process()-&gt;id()-&gt;unwrap();\n</code></pre>"},{"location":"upgrade/v5-to-v6/#halt-current-process","title":"Halt current process","text":"BeforeAfter <pre><code>use Innmind\\TimeContinuum\\Earth\\Period\\Second;\n\n$os-&gt;process()-&gt;halt(new Second(1));\n</code></pre> <pre><code>use Innmind\\TimeContinuum\\Period;\n\n$os-&gt;process()-&gt;halt(Period::second(1))-&gt;unwrap();\n</code></pre>"},{"location":"upgrade/v5-to-v6/#mount-filesystem","title":"Mount filesystem","text":"BeforeAfter <pre><code>use Innmind\\Url\\Path;\n\n$adapter = $os\n    -&gt;filesystem()\n    -&gt;mount(Path::of('somewhere/'));\n</code></pre> <pre><code>use Innmind\\Url\\Path;\n\n$adapter = $os\n    -&gt;filesystem()\n    -&gt;mount(Path::of('somewhere/'))\n    -&gt;unwrap();\n</code></pre>"},{"location":"use_cases/filesystem/","title":"Filesystem","text":"<p>Like time the filesystem can be easily accessed with PHP builtin functions but is a source of implicits and state. To move away from these problems the filesystem here is considered as an immutable structure that you mount in your code. This forces you explicit what directories you are accessing and always verify that the structure you want to manipulate is as you expect.</p>"},{"location":"use_cases/filesystem/#examples","title":"Examples","text":""},{"location":"use_cases/filesystem/#doing-a-filesystem-backup","title":"Doing a filesystem backup","text":"<pre><code>use Innmind\\Filesystem\\Adapter;\nuse Innmind\\Url\\Path;\n\n$backup = function(Adapter $source, Adapter $target): void {\n    $source-&gt;all()-&gt;foreach(function($file) use ($target): void {\n        // $file can be either a concrete file or directory\n        $target-&gt;add($file);\n    });\n};\n$backup(\n    $os\n        -&gt;filesystem()\n        -&gt;mount(Path::of('/path/to/source/'))\n        -&gt;unwrap(),\n    $os\n        -&gt;filesystem()\n        -&gt;mount(Path::of('/path/to/target/'))\n        -&gt;unwrap(),\n);\n</code></pre> <p>Here we copy all the files from a local directory to another, but the <code>backup</code> function isn't aware of the locality of filesystems meaning that the source or target could be swapped to use remote filesystem (such as S3).</p>"},{"location":"use_cases/filesystem/#adding-a-file-in-a-subdirectory","title":"Adding a file in a subdirectory","text":"<pre><code>use Innmind\\Filesystem\\{\n    Adapter,\n    File,\n    File\\Content,\n    Directory,\n    Name,\n};\nuse Innmind\\Url\\Path;\nuse Innmind\\Immutable\\Predicate\\Instance;\n\n$addUserPicture = function(\n    Adapter $filesystem,\n    string $userId,\n    File $picture,\n): void {\n    $filesystem\n        -&gt;get(Name::of($userId))\n        -&gt;keep(Instance::of(Directory::class))\n        -&gt;otherwise(static fn() =&gt; Directory::named($userId))\n        -&gt;map(static fn($directory) =&gt; $directory-&gt;add($picture))\n        -&gt;match(\n            static fn($directory) =&gt; $filesystem-&gt;add($directory),\n            static fn() =&gt; null,\n        );\n};\n$addUserPicture(\n    $os\n        -&gt;filesystem()\n        -&gt;mount(Path::of('/path/to/users/data/'))\n        -&gt;unwrap(),\n    'some-unique-id',\n    File::named(\n        'picture.png',\n        Content::ofString(\n            \\file_get_contents($_FILES['some_file']['tmp_name']),\n        ),\n    ),\n);\n</code></pre> <p>Here you are forced to explicit the creation of the user directory instead of implicitly assuming it has been created by a previous process.</p> <p>Once again the function is unaware where the file comes from or where it will be stored and simply how the process of adding the picture works.</p>"},{"location":"use_cases/filesystem/#checking-if-a-file-exists","title":"Checking if a file exists","text":"<p>Sometimes you don't want to mount a filesystem in order to know if a file or directory exist as you only want to check for their existence.</p> <p>Example of checking if a <code>maintenance.lock</code> exist to prevent your webapp from running:</p> <pre><code>use Innmind\\Url\\Path;\n\n$path = Path::of('/path/to/project/maintenance.lock');\n\nif ($os-&gt;filesystem()-&gt;contains($path)) {\n    throw new \\RuntimeException('Application still in maintenance');\n}\n\n// run normal webapp here\n</code></pre> <p>Or you could check the existence of a directory that is required for another sub process to run correctly:</p> <pre><code>use Innmind\\Url\\Path;\n\n$path = Path::of('/path/to/some/required/folder/');\n\nif (!$os-&gt;filesystem()-&gt;contains($path)) {\n    $os\n        -&gt;control()\n        -&gt;processes()\n        -&gt;execute($mkdirCommand)\n        -&gt;unwrap();\n}\n\n$os\n    -&gt;control()\n    -&gt;processes()\n    -&gt;execute($subProcessCommand)\n    -&gt;unwrap();\n</code></pre> <p>See processes section on how to execute commands on your operating system.</p>"},{"location":"use_cases/filesystem/#mounting-the-tmp-folder","title":"Mounting the <code>tmp</code> folder","text":"<p>Sometimes you want to use the <code>tmp</code> folder to write down files such as cache that can be safely lost in case of a system reboot. You can easily mount this folder as any other folder like so:</p> <pre><code>use Innmind\\Filesystem\\Adapter;\n\n$tmp = $os\n    -&gt;filesystem()\n    -&gt;mount($os-&gt;status()-&gt;tmp())\n    -&gt;unwrap();\n$tmp instanceof Adapter; // true\n</code></pre> <p>It is a great way to forget about where the tmp folder is located and simply focus on what you need to do. And since you can use it as any other mounted filesystem you can change it for tests purposes.</p>"},{"location":"use_cases/filesystem/#watching-for-changes-on-the-filesystem","title":"Watching for changes on the filesystem","text":"<p>A pattern we don't see much in PHP is an infinite loop to react to an event to perform another task. Here we can build such pattern by watching for changes in a file or a directory.</p> <pre><code>use Innmind\\FileWatch\\Continuation;\n\n$runTests = $os-&gt;filesystem()-&gt;watch(Path::of('/path/to/project/src/'));\n\n$count = $runTests(\n    0,\n    function(int $count, Continuation $continuation) use ($os): Continuation {\n        if ($count === 42) {\n            return $continuation-&gt;stop($count);\n        }\n\n        $os\n            -&gt;control()\n            -&gt;processes()\n            -&gt;execute($phpunitCommand)\n            -&gt;unwrap();\n\n        return $continuation-&gt;continue(++$count);\n    },\n)-&gt;match(\n    static fn(int $count) =&gt; $count, // always 42 as it's the stopping value\n    static fn(\\Throwable $e) =&gt; throw $e,\n);\n</code></pre> <p>Here it will run phpunit tests every time the <code>src/</code> folder changes. Concrete examples of this pattern can be found in <code>innmind/lab-station</code> to run a suite of tools when sources change.</p> <p>This operation is a bit like an <code>array_reduce</code> as you can keep a state record between each calls of the callable via the first argument (here <code>0</code>, but it can be anything) and the argument of your callable will be the previous value returned by <code>$continuation-&gt;continue()</code>.</p> <p>Since there is no builtin way to watch for changes in a directory it checks the directory every second, so use it with care. Watching an individual file is a bit safer as it uses the <code>tail</code> command so there is no <code>sleep()</code> used.</p>"},{"location":"use_cases/http/","title":"HTTP Client","text":""},{"location":"use_cases/http/#calling-an-http-server","title":"Calling an HTTP server","text":"<pre><code>use Innmind\\Http\\{\n    Request,\n    Method,\n    Response,\n    ProtocolVersion,\n};\nuse Innmind\\Url\\Url;\n\n$http = $os-&gt;remote()-&gt;http();\n\n$response = $http(Request::of(\n    Url::of('https://github.com'),\n    Method::get,\n    ProtocolVersion::v20,\n))\n    -&gt;map(static fn($success) =&gt; $success-&gt;response())\n    -&gt;match(\n        static fn($response) =&gt; $response,\n        static fn($error) =&gt; throw new \\RuntimeException($error::class),\n    );\n$response instanceof Response; // true\n</code></pre> <p>All elements of a request/response call is built using objects to enforce correctness of the formatted messages.</p> <p>Since request and responses messages can be viewed either from a client or a server the model is abstracted in the standalone <code>innmind/http</code> library.</p>"},{"location":"use_cases/http/#resiliency-in-a-distributed-system","title":"Resiliency in a distributed system","text":"<p>One of the first things taught when working with distributed systems is that they will intermittently fail. To prevent your app to crash for an occasional failure a common pattern is the retry pattern with a backoff strategy allowing the client to retry safe requests a certain amount of time before giving up. You can use this pattern like so:</p> <pre><code>use Innmind\\OperatingSystem\\Config\\Resilient;\nuse Innmind\\HttpTransport\\ExponentialBackoff;\n\n$os = $os-&gt;map(Resilient::new());\n$http = $os-&gt;remote()-&gt;http();\n$http instanceof ExponentialBackoff; // true\n</code></pre> <p>Another strategy you can add on top of that is the circuit breaker pattern that will stop sending request to a server known to have failed.</p> <pre><code>use Innmind\\HttpTransport\\CircuitBreaker;\nuse Innmind\\TimeContinuum\\Period;\n\n$http = CircuitBreaker::of(\n    $http,\n    $os-&gt;clock(),\n    Period::minute(1),\n);\n$request = Request::of(/* ...args */)\n$response = $http($request);\n// if the previous call failed then the next call wil not even be sent to the\n// server and the client will respond immediately unless 1 minute has elapsed\n// between the 2 calls\n$response = $http($request);\n</code></pre> <p>The circuit breaker works on host per host basis meaning if <code>server1.com</code> fails then calls to <code>server2.com</code> will still be sent.</p>"},{"location":"use_cases/ipc/","title":"Inter Process Communication (IPC)","text":"<p>To communicate between processes on a same system there is 2 approaches: sharing memory or passing messages through a socket.</p> <p>The later is the safest of the two (but not exempt of problems) and you will find here the building blocks to communicate via a socket.</p> <p>The adage <code>share state through messages and not messages through state</code> is a pillar of the actor model and initially of object oriented programming.</p> ServerClient <pre><code>use Innmind\\IO\\Sockets\\Unix\\Address;\nuse Innmind\\Url\\Path;\nuse Innmind\\TimeContinuum\\Period;\nuse Innmind\\Immutable\\{\n    Sequence,\n    Str,\n};\n\n$server = $os\n    -&gt;sockets()\n    -&gt;open(Address::of(Path::of('/tmp/foo')))\n    -&gt;unwrap();\n    -&gt;timeoutAfter(Period::second(1));\n\nwhile (true) {\n    $_ = $server\n        -&gt;accept()\n        -&gt;match(\n            static fn($client) =&gt; $client\n                -&gt;sink(Sequence::of(Str::of('Hello')))\n                -&gt;flatMap(static fn() =&gt; $client-&gt;close())\n                -&gt;match(\n                    static fn() =&gt; null, // everyhting is ok\n                    static fn(\\Throwable $e) =&gt; throw $e,\n                ),\n            static fn() =&gt; null, // no new connection available\n        ),\n}\n</code></pre> <pre><code>use Innmind\\IO\\{\n    Sockets\\Unix\\Address,\n    Frame,\n};\nuse Innmind\\Url\\Path;\n\n$client = $os\n    -&gt;sockets()\n    -&gt;connectTo(Address::of(Path::of('/tmp/foo')))\n    -&gt;unwrap();\n\necho $client\n    -&gt;watch()\n    -&gt;frames(Frame::chunk(5)-&gt;strict())\n    -&gt;one()\n    -&gt;match(\n        static fn($data) =&gt; $data-&gt;toString(),\n        static fn() =&gt; 'unable to read the stream',\n    );\n</code></pre> <p>In the case the server is started first then the client would print <code>Hello</code>.</p> <p>This is a very rough implementation of communication between processes. DO NOT use this simple implementation in your code, instead use a higher level API such as <code>innmind/ipc</code>.</p>"},{"location":"use_cases/processes/","title":"Processes","text":"<p>Even though PHP started as a way to build dynamic websites it is more and more used to build CLI tools. A recurrent job is to start new processes (either PHP commands or any other cli tool), it can be done in a number of ways from the simple <code>exec()</code> function or the widespread <code>symfony/process</code> library. Like time they prevent your code from being unit tested as they directly call the operating system.</p> <p>This library makes the distinction from defining the user intent and the execution so it provides a higher level, more testable, API.</p>"},{"location":"use_cases/processes/#executing-a-process-on-the-system","title":"Executing a process on the system","text":"<pre><code>use Innmind\\Server\\Control\\Server\\{\n    Command,\n    Signal,\n};\n\n$webserver = $os\n    -&gt;control()\n    -&gt;processes()\n    -&gt;execute(\n        Command::foreground('php')\n            -&gt;withShortOption('S', 'localhost:8080'),\n    )\n    -&gt;unwrap();\n// do some stuff\n$webserver-&gt;pid()-&gt;match(\n    static fn($pid) =&gt; $os\n        -&gt;control()\n        -&gt;processes()\n        -&gt;kill($pid, Signal::kill)\n        -&gt;unwrap(),\n    static fn() =&gt; null, // background processes don't have a pid\n);\n</code></pre> <p>Here we start the PHP builtin webserver and perform some imaginary action before killing it, but you could also wait the process to finish (see below) instead of killing it (in the case of the webserver it never finishes unless with a crash).</p> <pre><code>use Innmind\\Server\\Control\\Server\\Command;\n\n$webserver = $os\n    -&gt;control()\n    -&gt;processes()\n    -&gt;execute(\n        Command::foreground('php')\n            -&gt;withShortOption('S', 'localhost:8080'),\n    )\n    -&gt;unwrap();\n$webserver-&gt;wait();\n</code></pre> <p>Or you could start the process as an independent one (meaning you can't control it anymore) by changing <code>Command::foreground()</code> to <code>Command::background()</code>.</p> <pre><code>use Innmind\\Server\\Control\\Server\\Command;\n\n$os\n    -&gt;control()\n    -&gt;processes()\n    -&gt;execute(\n        Command::background('php')\n            -&gt;withShortOption('S', 'localhost:8080'),\n    )\n    -&gt;unwrap();\n</code></pre>"},{"location":"use_cases/processes/#executing-processes-on-a-remote-machine","title":"Executing processes on a remote machine","text":"<p>It uses the same abstraction as running processes on the local machine so you can easily reuse code.</p> <pre><code>use Innmind\\Server\\Control\\Server;\nuse Innmind\\Url\\Url;\n\n$installMariadb = function(Server $server): void {\n    // todo run the commands to install mariadb\n};\n$installMariadb($os-&gt;control());\n$installMariadb($os-&gt;remote()-&gt;ssh(Url::of('ssh://user@replication1')));\n$installMariadb($os-&gt;remote()-&gt;ssh(Url::of('ssh://user@replication2')));\n</code></pre>"},{"location":"use_cases/processes/#listing-all-the-processes-running-on-the-machine","title":"Listing all the processes running on the machine","text":"<pre><code>use Innmind\\Server\\Status\\Server\\Process;\nuse Innmind\\TimeContinuum\\Format;\n\n$os-&gt;status()-&gt;processes()-&gt;all()-&gt;foreach(function(Process $process): void {\n    \\printf(\n        \"Process %s started by %s at %s\\n\",\n        $process-&gt;command()-&gt;toString(),\n        $process-&gt;user()-&gt;toString(),\n        $process-&gt;start()-&gt;match(\n            static fn($date) =&gt; $date-&gt;format(Format::iso8601()),\n            static fn() =&gt; 'unknown start date',\n        ),\n    );\n});\n</code></pre>"},{"location":"use_cases/processes/#starting-a-new-process-if-not-already-started","title":"Starting a new process if not already started","text":"<p>This is useful, though not completely safe (race condition), to start a command that shouldn't be run in parallel.</p> <pre><code>use Innmind\\Server\\Control\\Server\\Command;\nuse Innmind\\Immutable\\RegExp;\n\n$backupRunning = $os\n    -&gt;status()\n    -&gt;processes()\n    -&gt;all()\n    -&gt;any(\n        fn($process): bool =&gt; $process\n            -&gt;command()\n            -&gt;matches(RegExp::of('~my-backup-tool~')),\n    );\n\nif (!$backupRunning) {\n    $os\n        -&gt;control()\n        -&gt;processes()\n        -&gt;execute(\n            Command::background('my-backup-tool'),\n        )\n        -&gt;unwrap();\n}\n</code></pre>"},{"location":"use_cases/processes/#stopping-or-rebooting-a-machine","title":"Stopping or rebooting a machine","text":"<pre><code>use Innmind\\Url\\Url;\n\n$os-&gt;control()-&gt;reboot()-&gt;unwrap();\n$os-&gt;control()-&gt;shutdown()-&gt;unwrap();\n$os-&gt;remote()-&gt;ssh(Url::of('ssh://user@remote-server'))-&gt;reboot()-&gt;unwrap();\n$os-&gt;remote()-&gt;ssh(Url::of('ssh://user@remote-server'))-&gt;shutdown()-&gt;unwrap();\n</code></pre>"},{"location":"use_cases/signals/","title":"Handling process signals","text":"<p>Any process can receive signals either through user interaction (in a terminal), from another process or via the <code>kill</code> command. PHP processes can handle them and perform actions to safely free resources or prevent the process from being terminated.</p> <p>Examples below only use one listener per signal but you can add as many as you wish (which is complicated when dealing manually with PHP builtin functions).</p>"},{"location":"use_cases/signals/#free-resources-before-stopping","title":"Free resources before stopping","text":"<p>This is a reuse of the socket example.</p> <pre><code>use Innmind\\Url\\Url;\nuse Innmind\\IO\\{\n    Sockets\\Internet\\Transport,\n    Frame,\n};\nuse Innmind\\TimeContinuum\\Period;\nuse Innmind\\Signals\\Signal;\nuse Innmind\\Immutable\\{\n    Sequence,\n    Str,\n};\n\n$client = $os\n    -&gt;remote()\n    -&gt;socket(Transport::tcp(), Url::of('tcp://127.0.0.1:8080')-&gt;authority())\n    -&gt;unwrap();\n$signaled = true;\n$os\n    -&gt;process()\n    -&gt;signals()\n    -&gt;listen(Signal::terminate, function() use (&amp;$signaled) {\n        $signaled = false;\n    });\n\n$receivedData = $client\n    -&gt;timeoutAfter(Period::second(1))\n    // it sends this every second to keep the connection alive\n    -&gt;heartbeatWith(static fn() =&gt; Sequence::of(Str::of('foo')))\n    -&gt;abortWhen(function() use (&amp;$signaled) {\n        return $signaled;\n    })\n    -&gt;frames(Frame::chunk(1)-&gt;strict())\n    -&gt;one()\n    -&gt;match(\n        static fn() =&gt; true,\n        static fn() =&gt; false,\n    );\n\nif ($receivedData) {\n    echo 'Server has responded'.\n}\n\n$client-&gt;close()-&gt;unwrap();\n</code></pre> <p>When the process receive the <code>SIGTERM</code> signal it will be paused then the anonymous function will be called and the process will then be resumed.</p> <p>Signal handling is already performed when using <code>innmind/ipc</code> or <code>innmind/amqp</code> so you don't have to think about it.</p>"},{"location":"use_cases/signals/#prevent-process-from-being-stopped","title":"Prevent process from being stopped","text":"<pre><code>$prevent = function() {\n    echo 'Process cannot be interrupted in the middle of a backup';\n};\n\n$os-&gt;process()-&gt;signals()-&gt;listen(Signal::terminate, $prevent);\n$os-&gt;process()-&gt;signals()-&gt;listen(Signal::interrupt, $prevent);\n\n// perform the backup here that can't be stopped to prevent data corruption\n\n$os-&gt;process()-&gt;signals()-&gt;remove($prevent);\n</code></pre> <p>This example will prevent the process from being terminated by a <code>SIGTERM</code> or <code>SIGINT</code> while in the middle of a backup, but if the signals comes before or after the backup then the process will be terminated as expected.</p>"},{"location":"use_cases/socket/","title":"Socket communication","text":"<p>This topic is similar to the Inter Process Communication but address talking to a socket through a specific network port (either locally or remotely).</p> <p>As you'll see below working with sockets (<code>.sock</code> or a port) is always the same workflow:</p> <ul> <li>open a socket (client or server)</li> <li>watch for them to be ready to read</li> <li>perform an action on the socket when ready</li> </ul>"},{"location":"use_cases/socket/#opening-a-port","title":"Opening a port","text":"<p>The use case is not very common as you need to define a protocol and implement security but can still have some use for a secure network.</p> <pre><code>use Innmind\\Url\\Authority\\Port;\nuse Innmind\\IO\\Sockets\\Internet\\Transport;\nuse Innmind\\IP\\IPv4;\nuse Innmind\\TimeContinuum\\Period;\n\n$server = $os\n    -&gt;ports()\n    -&gt;open(Transport::tcp(), IPv4::localhost(), Port::of(8080))\n    -&gt;unwrap()\n    -&gt;timeoutAfter(Period::second(1));\n\nwhile (true) {\n    $server\n        -&gt;accept()\n        -&gt;match(\n            static fn($client) =&gt; /* talk to the client */,\n            static fn() =&gt; null, // no client available yet\n        );\n}\n</code></pre> <p>This is similar to the IPC example but instead of using a socket file the server is exposed at <code>tcp://127.0.0.1:8080</code> and can be accessed from outside the server.</p>"},{"location":"use_cases/socket/#opening-a-connection-to-an-opened-port","title":"Opening a connection to an opened port","text":"<p>This example will open a connection to the server defined above but can be changed to talk to an HTTP server or an AMQP Server.</p> <pre><code>use Innmind\\Url\\Url;\nuse Innmind\\IO\\{\n    Sockets\\Internet\\Transport,\n    Frame,\n};\n\n$receivedData = $os\n    -&gt;remote()\n    -&gt;socket(Transport::tcp(), Url::of('tcp://127.0.0.1:8080')-&gt;authority())\n    -&gt;unwrap()\n    -&gt;watch()\n    -&gt;frames(Frame::chunk(1)-&gt;strict())\n    -&gt;one()\n    -&gt;match(\n        static fn() =&gt; true,\n        static fn() =&gt; false,\n    );\n\nif ($receivedData) {\n    echo 'Server has responded'.\n}\n</code></pre>"},{"location":"use_cases/sql/","title":"SQL connection","text":"<p>You can build a connection to a SQL server like so:</p> <pre><code>use Innmind\\Url\\Url;\nuse Formal\\AccessLayer\\Connection;\n\n$connection = $os\n    -&gt;remote()\n    -&gt;sql(Url::of('mysql://127.0.0.1:3306/database_name'));\n\n$connection instanceof Connection; // true\n</code></pre> <p>By default it uses a lazy connection, meaning it won't open the connection until the first query.</p> <p>For more information on to query the database with this abstraction, visit the dedicated documentation.</p>"},{"location":"use_cases/time/","title":"Manipulating time","text":"<p>Directly accessing time in a PHP code is straightforward (either via <code>DateTime</code> or time functions) but it prevents you to build testable code or require to use some hard to understand hacks. Instead it is simpler to think of time as another dependency that you need to inject in your code, thus easier to change the implementation when testing.</p> Tip <p>For a more in length presentation of why directly accessing time is problematic you can watch this talk (in french).</p>"},{"location":"use_cases/time/#accessing-time","title":"Accessing time","text":"<pre><code>use Innmind\\TimeContinuum\\PointInTime;\n\n$isItMonday = function(PointInTime $point): bool {\n    return $point-&gt;day()-&gt;ofWeek()-&gt;toInt() === 1; // 0 for sunday\n};\n\n$now = $os-&gt;clock()-&gt;now();\n$now instanceof PointInTime; // true\n$isItMonday($now);\n</code></pre> <p>To access the time you need to go through the system clock. The <code>PointInTime</code> objects are immutable it prevents you from having side effects.</p> <p>For such example you could write unit tests by manually instaciating instances of <code>PointInTime</code> and verify that the function works as expected for every day of the week.</p>"},{"location":"use_cases/time/#haltering-the-time-in-your-app","title":"Haltering the time in your app","text":"<p>In some cases you may want your program to wait for a certain amount of time before continuing its job. A good example is a web crawler where you want to respect the crawler delay specified in the website <code>robots.txt</code> to avoid overloading the website server.</p> <pre><code>use Innmind\\OperatingSystem\\CurrentProcess;\nuse Innmind\\TimeContinuum\\Period;\n\n$crawl = function(CurrentProcess $process, string ...$urls): void {\n    foreach ($urls as $url) {\n        // crawl the $url and do something with the result\n\n        // here for the sake of simplicity we specify 1 second but it can be\n        // any instance of Innmind\\TimeContinuum\\Period and you could build\n        // it from a robots.txt Crawler-Delay directive\n        $process-&gt;halt(Period::second(1));\n    }\n};\n$crawl($os-&gt;process(), 'http://google.com', 'http://github.com');\n</code></pre> <p>Once again you can change the implementation of <code>CurrentProcess</code> when unit testing your function so it doesn't have to really wait for the specified amount of time while still verifying it is instructed to wait for a given period.</p>"}]}